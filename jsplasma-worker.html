<!DOCTYPE html>
<html>
<head>
  <style>
    body {
      display: block;
    }

    canvas {
      border: 1px solid #d3d3d3;
    }

    #gradient {
      width: 512px;
      height: 2em;
    }

    #gradient-colors {
      position: relative;
      width: 512px;
      height: 25px;
      margin: 5px 0 5px 0;
    }

    .container {
      display: flex;
    }

    #plasma {
      width: 512px;
      height: 512px;
    }

    input.color-choice {
      padding: 0;
      border: none;
      background: none;
      outline: none;
      position: absolute;
    }
  </style>
  </head>
<body>
  <div class='container'>
    <canvas id='plasma' width='512' height='512'></canvas>
  </div>
  <div id='gradient-colors'></div>
  <div class='container'>
    <canvas id='gradient' height='1'></canvas>
  </div>

  <!-- end of html content; only scripting below -->

<script id='worker' type='text/js-worker'>
// dedicated worker that does the math in the background
'use strict';
var width, height;
var gradient;

// x and y are valued in the range -1..1
function colorValue(x, y, t) {
  var dx = x + Math.cos(t) * 2;
  var dy = y + Math.sin(t/1.5) * 1.5;
  var terms = [
      //2 * Math.sin(t/5+dx) * (x * Math.cos(t/5) + y * Math.sin(t/7+dx)) + t/2,
      1.7 * x * Math.sin(t/9+dy) + y * Math.cos(t/6.1+dx) + t/2,
      2 * x * Math.sin(t/2) + y * Math.cos(t/3) + t,
      Math.sqrt(Math.sin(dy/1.8) * Math.sin(dy/2) +
                Math.cos(dx/2.3) * Math.cos(dx/2.3) + 1) + t,
    ];
  var summedSines = terms.reduce(function(a, b) { return a + Math.sin(b); }, 0);
  var index = summedSines / terms.length * 1023.5 + 1023.5;
  return gradient[index | 0];
}

var randSeed = (Math.random() - 0.5) * 10000;
function renderFrame(buffer, t) {
  t = (t + randSeed) / 1000;
  var index = 0;
  for (let row = 0; row < height; ++row) {
    var y = (row / height * 2) - 1;
    for (let col = 0; col < width; ++col) {
      var x = (col / width * 2) - 1;
      var color = colorValue(x, y, t);
      buffer[index++] = color[0];
      buffer[index++] = color[1];
      buffer[index++] = color[2];
      buffer[index++] = 255;
    }
  }
}

function DoubleBuffer(width, height) {
  var _active = 0;
  var _buffers = new Array(2);
  _buffers[0] = new ArrayBuffer(width * height * 4);
  _buffers[1] = new ArrayBuffer(width * height * 4);
  var _count = 2;

  // assign buffer to the non-active slot
  this.push = function(buffer) {
    if (_count == 0) {
      _buffers[_active] = buffer;
    } else if (_count == 1) {
      _buffers[_active ^ 1] = buffer;
    } else if (_count == 2) {
      throw 'DoubleBuffer overflowed';
    }
    ++_count;
  }

  // return the buffer in the active slot, toggle active slot value
  this.pop = function() {
    if (_count == 0) {
      return null;
    }
    --_count;
    var buff = _buffers[_active];
    _buffers[_active] = null;
    _active ^= 1;
    return buff;
  }
}

var doubleBuffer;
var running = false;
onmessage = function(event) {
  if (event.data instanceof ArrayBuffer) {
    doubleBuffer.push(event.data);
  }
  else if (event.data.msg_type === 'dimensions') {
    width = event.data.msg_value[0];
    height = event.data.msg_value[1];
    doubleBuffer = new DoubleBuffer(width, height);
  }
  else if (event.data.msg_type === 'gradient') {
    gradient = event.data.msg_value;
  }
  else if (event.data.msg_type === 'start') {
    if (!running) {
      running = true;
      (function renderLoop() {
          var buffer = doubleBuffer.pop();
          if (buffer) {
            renderFrame(new Uint8ClampedArray(buffer), performance.now());
            postMessage(buffer, [buffer]);
          }
          if (running) {
            setTimeout(renderLoop, 0);
          }
        })();
    }
  }
  else if (event.data.msg_type === 'stop') {
    running = false;
  }
}
</script> <!-- end of worker -->

<script type='text/javascript'>
'use strict';
//setInterval(() => { console.warn('Auto-Reloading...'); location.reload(true); }, 60000);

var ctx = document.getElementById('plasma').getContext('2d')
var inflectionPts = [
    '#190934',
    '#fba90a',
    '#5a18c9',
    '#d4e4f7',
    '#236ab9',
    '#72ff72',
  ];
var gradient;

// load worker from script with id='worker'
var blob = new Blob([document.getElementById('worker').textContent],
                    {type: 'text/javascript'});
var worker = new Worker(window.URL.createObjectURL(blob));
worker.postMessage({ msg_type: 'dimensions',
                     msg_value: [ ctx.canvas.clientWidth,
                                  ctx.canvas.clientHeight ]});

worker.onmessage = function(event) {
  var buffer = event.data;
  var currentFrame = new ImageData(new Uint8ClampedArray(buffer),
                                   ctx.canvas.clientWidth,
                                   ctx.canvas.clientHeight);
  window.requestAnimationFrame(function() {
      ctx.putImageData(currentFrame, 0, 0);
      worker.postMessage(buffer, [buffer]);
    });
}
worker.onerror = function(event) {
  console.error(event);
}

// create a wrapping color gradient through all specified colors
//   - colors may be specified as [r,g,b], 0xrrggbb, or '#rrggbb'
function createGradient(inflectionPts) {
  function rgbSplit(color) {
    if (typeof color === 'object') {
      return color;
    } else if (typeof color === 'string' && color[0] === '#') {
      return rgbSplit(parseInt(color.slice(1), 16));
    } else {
      return [ color >> 16, (color >> 8) & 0xff, color & 0xff ];
    }
  }

  var gradient = new Array(2048);
  var index = 0;
  for (let pt = 0; pt < inflectionPts.length; ++pt) {
    var startColor = rgbSplit(inflectionPts[pt]);
    var endColor = rgbSplit(inflectionPts[(pt + 1) % inflectionPts.length]);
    var endIndex = gradient.length / inflectionPts.length * (pt + 1);
    var increment = [
      (endColor[0] - startColor[0]) / (endIndex - index),
      (endColor[1] - startColor[1]) / (endIndex - index),
      (endColor[2] - startColor[2]) / (endIndex - index),
      ];
    var color = startColor.slice();
    for (; index < endIndex; ++index) {
      gradient[index] = [
        Math.floor(color[0]),
        Math.floor(color[1]),
        Math.floor(color[2])
        ];
      color[0] += increment[0];
      color[1] += increment[1];
      color[2] += increment[2];
    }
  }
  return gradient;
}

function showGradient(ctx, gradient) {
  document.getElementById('gradient').width = gradient.length * 2;
  var imgData = ctx.createImageData(gradient.length * 2, ctx.canvas.clientHeight);
  for (let i = 0; i < imgData.data.length; i += 4) {
    imgData.data[i]   = gradient[i/4 % gradient.length][0];
    imgData.data[i+1] = gradient[i/4 % gradient.length][1];
    imgData.data[i+2] = gradient[i/4 % gradient.length][2];
    imgData.data[i+3] = 255;
  }
  ctx.putImageData(imgData, 0, 0);
}

function updateGradient() {
  // use the colors from left to right, not the order they were added to the
  // container div
  var colors = Array.from(document.getElementsByClassName('color-choice'));
  colors.sort(function(a, b) {
      return parseFloat(a.style.left) - parseFloat(b.style.left);
    });

  inflectionPts = [];
  for (let i = 0; i < colors.length; ++i) {
    inflectionPts.push(colors[i].value);
  }
  gradient = createGradient(inflectionPts);
  showGradient(document.getElementById('gradient').getContext('2d'), gradient);
  worker.postMessage({ msg_type: 'gradient',
                       msg_value: gradient });
}

var sliding = false;
function slide(elements, offset, duration=150) {
  sliding = true;
  var startingPos = [];
  var startingTime = performance.now();
  for (let i = 0; i < elements.length; ++i) {
    startingPos.push(parseFloat(elements[i].style.left));
  }

  // symmetric trapezoidal velocity profile; acceleration periods consist of
  // first and last quarter of duration with middle half having constant
  // velocity; time and distance are inputs, solve for max velocity
  var V = (4 / 3) * (offset / duration);
  var T = duration;

  (function animate(now) {
      var t = now - startingTime;

      var shift = offset;
      if (t < duration) {
        if (t <= duration * 0.25) {
          shift = 2 * t * t * V / T;
        } else if (t <= duration * 0.75) {
          shift = V * ((t - T * 0.25) + (0.125 * T));
        } else {
          shift = (0.125 * V * T) - ((T - t) * (4 * (T - t) * V / T) * 0.5) + 0.625 * V * T;
        }
      }

      for (let i = 0; i < elements.length; ++i) {
        // apply a shift from the starting position to avoid accumulating errors
        elements[i].style.left = (startingPos[i] + shift) + 'px';
      }

      if (Math.abs(shift) < Math.abs(offset)) {
        requestAnimationFrame(animate);
      } else {
        updateGradient();
        sliding = false;
      }
    })(performance.now());
}

function updateColorChoices() {
  var container = document.getElementById('gradient-colors');
  while (container.hasChildNodes()) {
    container.removeChild(container.lastChild);
  }

  var elemHeight = container.clientHeight;
  var elemGap = elemHeight / 4;
  var elemWidth = (container.clientWidth - elemGap * (inflectionPts.length - 1))
                   / inflectionPts.length;
  var draggedElem; // used in listeners
  for (let i = 0; i < inflectionPts.length; ++i) {
    var inp = document.createElement('input');
    inp.setAttribute('class', 'color-choice');
    inp.setAttribute('id', 'color-' + i);
    inp.setAttribute('type', 'color');
    inp.setAttribute('draggable', 'true');
    inp.setAttribute('value', inflectionPts[i]);
    inp.addEventListener('change', updateGradient);
    inp.addEventListener('input', updateGradient);
    inp.style.height = elemHeight + 'px';
    inp.style.width = Math.round(elemWidth) + 'px';
    inp.style.left = Math.round((elemWidth + elemGap) * i) + 'px';
    container.append(inp);

    inp.addEventListener('dragstart', function(event) {
        draggedElem = this;
      });
    inp.addEventListener('dragenter', function(event) {
        event.preventDefault();
        if (draggedElem === this || sliding) return;
        var elems = Array.from(document.getElementsByClassName('color-choice'));
        var direction = 1;
        if (parseFloat(draggedElem.style.left) < parseFloat(this.style.left)) {
          direction = -1;
          elems = elems.filter(
            elem => parseFloat(elem.style.left) <= parseFloat(this.style.left) &&
                    parseFloat(elem.style.left) > parseFloat(draggedElem.style.left));
        } else {
          elems = elems.filter(
            elem => parseFloat(elem.style.left) >= parseFloat(this.style.left) &&
                    parseFloat(elem.style.left) < parseFloat(draggedElem.style.left));
        }
        slide([draggedElem], parseFloat(this.style.left) - parseFloat(draggedElem.style.left));
        slide(elems, (elemGap + elemWidth) * direction);
      });
    inp.addEventListener('dragover', function(event) {
        event.preventDefault();
      });
  }
  updateGradient();
}
updateColorChoices();

worker.postMessage({ msg_type: 'start' });

</script>
</body>
</html>

